/**
 * LSPosedKit Module Scaffolding Script
 * 
 * Usage: ./gradlew -P:scripts:newModule -Pname="ModuleName" -Pid="module-id" [-Pdescription="Module description"]
 * 
 * This script generates a complete module structure with:
 * - Module source directory structure
 * - Main module class with @XposedPlugin annotation
 * - build.gradle file
 * - settings.json schema
 * - module-info.json metadata
 * - Basic hook example
 */

apply plugin: 'base'

task newModule {
    description = 'Creates a new LSPosedKit module with boilerplate code'
    group = 'LSPosedKit'
    
    doLast {
        // Properly handle project properties to avoid conflicts with built-in project.name
        // -P properties are always set on the rootProject, not the subproject
        def moduleName = null
        def moduleId = null
        def moduleDescription = "Generated LSPosedKit module"
        def moduleAuthor = "LSPosedKit Developer"
        def moduleScope = "*"
        
        // Access command line properties correctly using gradle.startParameter.projectProperties
        // This avoids conflicts with built-in project properties like project.name
        def projectProperties = gradle.startParameter.projectProperties
        
        if (projectProperties.containsKey('moduleName')) {
            moduleName = projectProperties.get('moduleName')
        }
        
        if (projectProperties.containsKey('id')) {
            moduleId = projectProperties.get('id')
        }
        
        if (projectProperties.containsKey('description')) {
            moduleDescription = projectProperties.get('description')
        }
        
        if (projectProperties.containsKey('author')) {
            moduleAuthor = projectProperties.get('author')
        }
        
        if (projectProperties.containsKey('scope')) {
            moduleScope = projectProperties.get('scope')
        }
        
        // Validate required parameters
        if (!moduleName) {
            throw new GradleException("Module name is required. Use -PmoduleName='ModuleName'")
        }
        if (!moduleId) {
            throw new GradleException("Module ID is required. Use -Pid='module-id'")
        }
        
        // Validate module ID format
        if (!moduleId.matches(/^[a-z0-9-]+$/)) {
            throw new GradleException("Module ID must contain only lowercase letters, numbers, and hyphens")
        }
        
        // Generate paths and package names
        def moduleDir = new File(rootProject.projectDir, "modules/${moduleName}")
        def packageName = "com.wobbz.module.${moduleId.replace('-', '')}"
        def packagePath = packageName.replace('.', '/')
        
        // Check if module already exists
        if (moduleDir.exists()) {
            throw new GradleException("Module '${moduleName}' already exists at ${moduleDir.absolutePath}")
        }
        
        println "Creating module '${moduleName}' (${moduleId})..."
        println "Location: ${moduleDir.absolutePath}"
        println "Package: ${packageName}"
        
        // Create directory structure
        def srcDir = new File(moduleDir, "src/main/java/${packagePath}")
        def assetsDir = new File(moduleDir, "src/main/assets")
        def testDir = new File(moduleDir, "src/test/java/${packagePath}")
        def hooksDir = new File(srcDir, "hooks")
        
        [srcDir, assetsDir, testDir, hooksDir].each { dir ->
            if (!dir.mkdirs() && !dir.exists()) {
                throw new GradleException("Failed to create directory: ${dir.absolutePath}")
            }
        }
        
        // Generate main module class
        def moduleClassContent = generateModuleClass(moduleName, moduleId, moduleDescription, moduleAuthor, moduleScope, packageName)
        new File(srcDir, "${moduleName}.kt").text = moduleClassContent
        
        // Generate example hooker class
        def hookerClassContent = generateExampleHooker(moduleName, packageName)
        new File(hooksDir, "Example${moduleName}Hooker.kt").text = hookerClassContent
        
        // Generate build.gradle
        def buildGradleContent = generateBuildGradle(packageName)
        new File(moduleDir, "build.gradle").text = buildGradleContent
        
        // Generate settings.json
        def settingsJsonContent = generateSettingsJson(moduleName)
        new File(assetsDir, "settings.json").text = settingsJsonContent
        
        // Generate module-info.json template (will be overridden by annotation processor)
        def moduleInfoContent = generateModuleInfo(moduleId, moduleName, moduleDescription, moduleAuthor)
        new File(assetsDir, "module-info.json").text = moduleInfoContent
        
        // Generate unit test
        def testClassContent = generateUnitTest(moduleName, packageName)
        new File(testDir, "${moduleName}Test.kt").text = testClassContent
        
        // Generate README
        def readmeContent = generateReadme(moduleName, moduleId, moduleDescription)
        new File(moduleDir, "README.md").text = readmeContent
        
        // Update settings.gradle to include the new module
        updateSettingsGradle(moduleName)
        
        println ""
        println "✅ Module '${moduleName}' created successfully!"
        println ""
        println "Next steps:"
        println "1. Sync your IDE to recognize the new module"
        println "2. Implement your hooks in ${hooksDir.absolutePath}"
        println "3. Customize settings in ${assetsDir.absolutePath}/settings.json"
        println "4. Build with: ./gradlew :modules:${moduleName}:assembleDebug"
        println "5. Install with: ./gradlew :modules:${moduleName}:installDebug"
    }
}

def generateModuleClass(String moduleName, String moduleId, String description, String author, String scope, String packageName) {
    return """package ${packageName}

import android.content.Context
import com.wobbz.framework.core.IModulePlugin
import com.wobbz.framework.core.LogLevel
import com.wobbz.framework.core.ModuleLifecycle
import com.wobbz.framework.core.PackageLoadedParam
import com.wobbz.framework.hot.IHotReloadable
import com.wobbz.framework.processor.HotReloadable
import com.wobbz.framework.processor.XposedPlugin
import com.wobbz.framework.settings.SettingsProvider
import ${packageName}.hooks.Example${moduleName}Hooker

@XposedPlugin(
    id = "${moduleId}",
    name = "${moduleName}",
    version = "1.0.0",
    description = "${description}",
    author = "${author}",
    scope = ["${scope}"]
)
@HotReloadable
class ${moduleName} : IModulePlugin, IHotReloadable, ModuleLifecycle {
    
    private val hooks = mutableListOf<Any>()
    private lateinit var settings: SettingsProvider
    
    override fun initialize(context: Context, xposed: com.wobbz.framework.core.XposedInterface) {
        // Initialize settings
        settings = SettingsProvider.of(context)
        
        xposed.log(LogLevel.INFO, "${moduleName} initialized")
    }
    
    override fun onStart() {
        // Called when all module dependencies are satisfied
        // Perform any initialization that requires other services
    }
    
    override fun onStop() {
        // Called when the module is being unloaded
        // Clean up resources and unregister services
        hooks.clear()
    }
    
    override fun onPackageLoaded(param: PackageLoadedParam) {
        // Check if we should hook this package
        if (!shouldHookPackage(param.packageName)) {
            return
        }
        
        try {
            // Example: Hook a method in the target application
            // Replace this with your actual hooking logic
            val targetClass = param.xposed.loadClass("android.app.Activity")
            val onCreateMethod = targetClass.getDeclaredMethod("onCreate", android.os.Bundle::class.java)
            
            val unhooker = param.xposed.hook(onCreateMethod, Example${moduleName}Hooker::class.java)
            hooks.add(unhooker)
            
            param.xposed.log(LogLevel.INFO, "Hooked Activity.onCreate for \${param.packageName}")
        } catch (e: Exception) {
            param.xposed.logError("Error setting up ${moduleName} hooks", e)
        }
    }
    
    private fun shouldHookPackage(packageName: String): Boolean {
        // Check module settings to determine if this package should be hooked
        val enabledForAll = settings.bool("enable_for_all", false)
        
        if (enabledForAll) {
            val excludedPackages = settings.stringSet("excluded_packages", emptySet())
            return !excludedPackages.contains(packageName)
        } else {
            val includedPackages = settings.stringSet("included_packages", emptySet())
            return includedPackages.contains(packageName)
        }
    }
    
    override fun onHotReload() {
        // Clean up existing hooks for hot-reload
        hooks.forEach { unhooker ->
            if (unhooker is com.wobbz.framework.core.MethodUnhooker<*>) {
                unhooker.unhook()
            }
        }
        hooks.clear()
    }
}
"""
}

def generateExampleHooker(String moduleName, String packageName) {
    return """package ${packageName}.hooks

import com.wobbz.framework.core.HookParam
import com.wobbz.framework.core.Hooker

/**
 * Example hooker for ${moduleName}.
 * This is a template - replace with your actual hooking logic.
 */
class Example${moduleName}Hooker : Hooker {
    
    override fun beforeHook(param: HookParam) {
        // Called before the original method executes
        // Note: Use android.util.Log directly since HookParam doesn't provide logging
        android.util.Log.d("${moduleName}", "Example${moduleName}Hooker: beforeHook called")
        
        // Example: Log method parameters
        param.args.forEachIndexed { index, arg ->
            android.util.Log.d("${moduleName}", "Param[\$index]: \${arg?.toString() ?: "null"}")
        }
        
        // Example: Modify parameters
        // param.args[0] = "modified_value"
        
        // Example: Block method execution
        // if (shouldBlockMethod()) {
        //     param.setResult(null)
        // }
    }
    
    override fun afterHook(param: HookParam) {
        // Called after the original method executes (or after beforeHook if result was set)
        android.util.Log.d("${moduleName}", "Example${moduleName}Hooker: afterHook called")
        
        // Example: Log the result
        val result = param.getResult<Any>()
        android.util.Log.d("${moduleName}", "Method result: \${result?.toString() ?: "null"}")
        
        // Example: Modify the result
        // param.setResult("modified_result")
    }
    
    private fun shouldBlockMethod(): Boolean {
        // Add your logic here
        return false
    }
}
"""
}

def generateBuildGradle(String packageName) {
    return """plugins {
    id 'com.android.library'
    id 'org.jetbrains.kotlin.android'
    id 'org.jetbrains.kotlin.kapt'
}

android {
    namespace '${packageName}'
    compileSdk rootProject.ext.compileSdk
    
    defaultConfig {
        minSdk rootProject.ext.minSdk
        targetSdk rootProject.ext.targetSdk
        
        consumerProguardFiles "consumer-rules.pro"
    }
    
    compileOptions {
        sourceCompatibility rootProject.ext.javaVersion
        targetCompatibility rootProject.ext.javaVersion
    }
    
    kotlinOptions {
        jvmTarget = rootProject.ext.javaVersion.toString()
    }
}

dependencies {
    implementation project(':framework')
    kapt project(':framework:processor')
    
    // Testing
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.mockito:mockito-core:4.0.0'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
}
"""
}

def generateSettingsJson(String moduleName) {
    return """{
  "\$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "title": "${moduleName} Settings",
  "properties": {
    "enable_for_all": {
      "type": "boolean",
      "title": "Enable for all apps",
      "description": "Enable ${moduleName} for all apps (except excluded apps)",
      "default": false
    },
    "excluded_packages": {
      "type": "array",
      "title": "Excluded packages",
      "description": "Packages to exclude when 'Enable for all apps' is on",
      "items": {
        "type": "string"
      },
      "default": ["com.android.systemui", "com.android.settings"]
    },
    "included_packages": {
      "type": "array",
      "title": "Included packages",
      "description": "Packages to include when 'Enable for all apps' is off",
      "items": {
        "type": "string"
      },
      "default": []
    },
    "enable_logging": {
      "type": "boolean",
      "title": "Enable logging",
      "description": "Enable detailed logging for debugging",
      "default": false
    }
  }
}
"""
}

def generateModuleInfo(String moduleId, String moduleName, String description, String author) {
    return """{
  "id": "${moduleId}",
  "name": "${moduleName}",
  "version": "1.0.0",
  "description": "${description}",
  "author": "${author}",
  "features": [
    "${moduleId}.core"
  ],
  "capabilities": {
    "hotReload": true
  },
  "providedServices": {},
  "serviceDependencies": []
}
"""
}

def generateUnitTest(String moduleName, String packageName) {
    return """package ${packageName}

import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.mockito.Mockito.*

/**
 * Unit tests for ${moduleName}.
 * Note: This is a basic template. For integration testing with Xposed functionality,
 * you may need to set up additional test infrastructure.
 */
class ${moduleName}Test {
    
    private lateinit var module: ${moduleName}
    
    @Before
    fun setup() {
        module = ${moduleName}()
    }
    
    @Test
    fun testModuleInstantiation() {
        // Test that module can be instantiated
        assertNotNull("Module should be instantiated", module)
        assertTrue("Module should implement IModulePlugin", 
            module is com.wobbz.framework.core.IModulePlugin)
        assertTrue("Module should implement IHotReloadable", 
            module is com.wobbz.framework.hot.IHotReloadable)
        assertTrue("Module should implement ModuleLifecycle", 
            module is com.wobbz.framework.core.ModuleLifecycle)
    }
    
    @Test
    fun testLifecycleMethods() {
        // Test that lifecycle methods don't throw exceptions
        try {
            module.onStart()
            module.onStop()
        } catch (e: Exception) {
            fail("Lifecycle methods should not throw exceptions: \${e.message}")
        }
    }
    
    @Test
    fun testHotReload() {
        // Test that hot reload doesn't throw exceptions
        try {
            module.onHotReload()
        } catch (e: Exception) {
            fail("Hot reload should not throw exceptions: \${e.message}")
        }
    }
    
    // TODO: Add more specific tests for your module's functionality
    // For testing with actual Xposed functionality, you'll need to:
    // 1. Mock the XposedInterface
    // 2. Mock the Context
    // 3. Test your specific hook implementations
}
"""
}

def generateReadme(String moduleName, String moduleId, String description) {
    return """# ${moduleName}

${description}

## Module Information

- **ID**: `${moduleId}`
- **Version**: 1.0.0
- **Target**: Android 12+ (API 31+)

## Features

- Hot-reload support for development
- Configurable package filtering
- Debug logging support

## Settings

The module can be configured through LSPosed Manager or by editing the settings:

- **Enable for all apps**: Apply hooks to all applications (default: false)
- **Excluded packages**: Apps to exclude when "Enable for all apps" is on
- **Included packages**: Apps to include when "Enable for all apps" is off
- **Enable logging**: Enable detailed debug logging

## Development

### Building

```bash
./gradlew :modules:${moduleName}:assembleDebug
```

### Installing

```bash
./gradlew :modules:${moduleName}:installDebug
```

### Testing

```bash
./gradlew :modules:${moduleName}:test
```

### Hot Reload

During development, you can use hot-reload to quickly test changes:

1. Start the development server: `./gradlew runDevServer`
2. Make your changes
3. Rebuild and install: `./gradlew :modules:${moduleName}:installDebug`

## Implementation Notes

This module was generated using the LSPosedKit scaffolding system. The main implementation points are:

1. **Main Module Class**: `${moduleName}.kt` - Entry point and lifecycle management
2. **Hooks**: `hooks/` directory - Contains the actual hooking implementations
3. **Settings**: `assets/settings.json` - Configuration schema
4. **Tests**: `test/` directory - Unit tests for the module

## Customization

To customize this module for your needs:

1. Replace the example hooks in `hooks/Example${moduleName}Hooker.kt` with your implementation
2. Update the settings schema in `assets/settings.json` to match your configuration needs
3. Modify the package filtering logic in the main module class
4. Add additional hook classes as needed
5. Update tests to cover your specific functionality

## License

This module is part of the LSPosedKit project and follows the same license terms.
"""
}

def updateSettingsGradle(String moduleName) {
    def settingsFile = new File(rootProject.projectDir, "settings.gradle")
    def settingsContent = settingsFile.text
    
    // Check if the module is already included
    def moduleInclude = "include ':modules:${moduleName}'"
    if (!settingsContent.contains(moduleInclude)) {
        // Add the include statement
        settingsContent += "\n${moduleInclude}\n"
        settingsFile.text = settingsContent
        println "✅ Added module to settings.gradle"
    } else {
        println "ℹ️  Module already exists in settings.gradle"
    }
}

def generateLSPosedEntry(String moduleName, String packageName) {
    return """package ${packageName}

import io.github.libxposed.api.XposedModuleInterface
import com.wobbz.framework.core.PackageLoadedParam
import com.wobbz.framework.core.XposedInterfaceImpl

/**
 * LSPosed entry point for ${moduleName}.
 * This class implements the standard LSPosed interfaces and bridges to our LSPosedKit framework.
 */
class LSPosedEntry : XposedModuleInterface {
    
    override fun onPackageLoaded(param: XposedModuleInterface.PackageLoadedParam) {
        try {
            // Create our framework module
            val module = ${moduleName}()
            
            // Create a minimal XposedInterface implementation for the bridge
            val xposedInterface = XposedInterfaceImpl(
                libXposedInterface = object : io.github.libxposed.api.XposedInterface {
                    override fun getFrameworkName(): String = "LSPosedKit"
                    override fun getFrameworkVersion(): String = "1.0.0"
                    override fun getFrameworkVersionCode(): Long = 100
                    override fun getFrameworkPrivilege(): Int = io.github.libxposed.api.XposedInterface.FRAMEWORK_PRIVILEGE_APP
                    override fun hook(origin: java.lang.reflect.Method, hooker: Class<out io.github.libxposed.api.XposedInterface.Hooker>) = throw UnsupportedOperationException("Not implemented")
                    override fun hookClassInitializer(origin: Class<*>, hooker: Class<out io.github.libxposed.api.XposedInterface.Hooker>) = throw UnsupportedOperationException("Not implemented")
                    override fun hookClassInitializer(origin: Class<*>, priority: Int, hooker: Class<out io.github.libxposed.api.XposedInterface.Hooker>) = throw UnsupportedOperationException("Not implemented")
                    override fun hook(origin: java.lang.reflect.Method, priority: Int, hooker: Class<out io.github.libxposed.api.XposedInterface.Hooker>) = throw UnsupportedOperationException("Not implemented")
                    override fun hook(origin: java.lang.reflect.Constructor<*>, hooker: Class<out io.github.libxposed.api.XposedInterface.Hooker>) = throw UnsupportedOperationException("Not implemented")
                    override fun hook(origin: java.lang.reflect.Constructor<*>, priority: Int, hooker: Class<out io.github.libxposed.api.XposedInterface.Hooker>) = throw UnsupportedOperationException("Not implemented")
                    override fun deoptimize(method: java.lang.reflect.Method): Boolean = false
                    override fun deoptimize(constructor: java.lang.reflect.Constructor<*>): Boolean = false
                    override fun invokeOrigin(method: java.lang.reflect.Method, thisObject: Any?, vararg args: Any?): Any? = throw UnsupportedOperationException("Not implemented")
                    override fun invokeOrigin(constructor: java.lang.reflect.Constructor<*>, thisObject: Any, vararg args: Any?) = throw UnsupportedOperationException("Not implemented")
                    override fun invokeSpecial(method: java.lang.reflect.Method, thisObject: Any, vararg args: Any?): Any? = throw UnsupportedOperationException("Not implemented")
                    override fun invokeSpecial(constructor: java.lang.reflect.Constructor<*>, thisObject: Any, vararg args: Any?) = throw UnsupportedOperationException("Not implemented")
                    override fun newInstanceOrigin(constructor: java.lang.reflect.Constructor<*>, vararg args: Any?): Any = throw UnsupportedOperationException("Not implemented")
                    override fun newInstanceSpecial(constructor: java.lang.reflect.Constructor<*>, subClass: Class<*>, vararg args: Any?): Any = throw UnsupportedOperationException("Not implemented")
                    override fun log(message: String) = android.util.Log.i("LSPosedKit-${moduleName}", message)
                    override fun log(message: String, throwable: Throwable) = android.util.Log.e("LSPosedKit-${moduleName}", message, throwable)
                    override fun parseDex(dexData: java.nio.ByteBuffer, includeAnnotations: Boolean) = null
                    override fun getApplicationInfo() = param.getApplicationInfo()
                    override fun getRemotePreferences(group: String) = throw UnsupportedOperationException("Not implemented")
                    override fun listRemoteFiles(): Array<String> = emptyArray()
                    override fun openRemoteFile(name: String) = throw UnsupportedOperationException("Not implemented")
                },
                packageName = param.getPackageName()
            )
            
            // Create LSPosedKit PackageLoadedParam from libxposed param
            val lspkParam = PackageLoadedParam(
                packageName = param.getPackageName(),
                classLoader = param.getClassLoader(),
                xposed = xposedInterface,
                isSystemApp = param.getApplicationInfo().flags and android.content.pm.ApplicationInfo.FLAG_SYSTEM != 0,
                appInfo = param.getApplicationInfo()
            )
            
            // Initialize and call the module directly
            try {
                module.initialize(
                    context = android.app.Application(), // Placeholder context
                    xposed = xposedInterface
                )
            } catch (e: Exception) {
                android.util.Log.w("LSPosedKit-${moduleName}", "Module initialization failed, continuing anyway", e)
            }
            
            module.onPackageLoaded(lspkParam)
            
        } catch (e: Exception) {
            android.util.Log.e("LSPosedKit-${moduleName}", "Error in onPackageLoaded", e)
        }
    }
}
"""
}